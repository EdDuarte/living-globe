<html> 
<head> 
	<title>Dados Demograficos Mudiais </title> 
	<style> 
		body { margin: 0; } 
		canvas { width: 100%; height: 100%; horizontal-align:right; } 
	</style> 
</head> 
<body> 
	<script type="text/javascript" src="three.js"></script>
	<script type="text/javascript" src="OrbitControls.js"></script>
	<script type="text/javascript" src="TrackballControls.js"></script>
	<script type="text/javascript" src="Utils.js"></script>
	<script type="text/javascript" src="jquery.csv-0.71.min.js"></script>
	<script type="text/javascript" src="jquery-1.11.2.min.js"></script>
	<script type="text/javascript" src="numeral.min.js"></script>

<div id="parametros" style="z-index: 100; position: absolute; background-color:red;  top: 5px;
    left: 5px; 
height :100%;
width: 250px;">

<spam id="DadosPais" style="color: white;"></spam>

<select>
  <option value="1">População</option>
  <option value="2">Nascimentos/ano</option>
  <option value="3">Mortes/ano</option>
</select>

<BR><BR>

<select>
  <option value="1">População</option>
  <option value="2">Nascimentos/ano</option>
  <option value="3">Mortes/ano</option>
</select>
<select>
  <option value="1">Maior</option>
  <option value="2">Menor</option>
  <option value="2">Igual</option>
</select>
<input></input>
</div>

	<script> 
		var countryData;
		var countryRepresented = [];
		var countryBox = [];
		var maxPopulation=0, maxDensity=0, maxBirths=0, maxDeads=0;
		$(document).ready(function() {
		    $.ajax({
		        type: "GET",
		        url: "Dados/dados.csv",
		        dataType: "text",
		        success: function(data) {
		        	processData(data);}
		     });
		});

		function processData (data)
		{ 
			 countryData = CSVToArray(data);
			 analyseMaxValues ();
			 addData (countryData);
			 //alert (countryData.length);

		}

		function analyseMaxValues ()
		{
			//a ideia é gravar os valores maximos para fazer uma escala
			for (var i = 1 ; i < countryData.length-1 ; i++) {
	 
	            if (maxPopulation < parseInt((countryData[i][5])))
	            	maxPopulation = parseInt((countryData[i][5]))
	            if (maxDensity < parseInt((countryData[i][6])))
	            	maxDensity = parseInt((countryData[i][6]))
	            if (maxBirths < parseInt((countryData[i][8])))
	            	maxBirths = parseInt((countryData[i][8]))
	            if (maxDeads < parseInt((countryData[i][12])))
	            	maxDeads = parseInt((countryData[i][12]))
	        }
	        alert (maxPopulation);
	        alert (maxDensity);
	        alert (maxBirths);
	        alert (maxDeads);
		}
		var width = window.innerWidth;// * 0.8;
		var height = window.innerHeight;
		var aspectRatio = width / height;
		
		var scene = new THREE.Scene(); 
		var camera = new THREE.PerspectiveCamera( 75, width / height, 0.1, 1000 );
//		var camera = new THREE.OrthographicCamera( -3, 3, -3 / aspectRatio, 3 / aspectRatio, 1, 1000); 
		var controls = new THREE.TrackballControls(camera);
		var renderer = new THREE.WebGLRenderer();
		
		renderer.setSize( width, height ); 
		document.body.appendChild( renderer.domElement );

		//function add3dWorld() {
        var world = new THREE.SphereGeometry(60,25,25);
        //var texture = THREE.ImageUtils.loadTexture("imgs/earth_specularmap_high.jpg");
		var m1 = new THREE.MeshPhongMaterial({
				ambient: '#040404',
				specular: '#040404',
				shininess: 1,
		});
		m1.map = new THREE.ImageUtils.loadTexture("imgs/earth_specularmap_low.jpg");
		
		
		var sol = new THREE.DirectionalLight( 0xfffff, 1.5 ); 
		sol.position.set( 0, 0, 1 ); 
		scene.add( sol );
        
        var sol1 = new THREE.DirectionalLight( 0xfffff, 1.5 ); 
		sol1.position.set( 1, 0, 0 );
		scene.add( sol1 );

		var sol2 = new THREE.DirectionalLight( 0xfffff, 1.5 ); 
		sol2.position.set( 0, 1, 0 );
		scene.add( sol2 );

		/*var light2 = new THREE.AmbientLight(0xffffff);
		light2.position.set(0, -5, 0);
	  	scene.add(light2);*/

        var sp = new THREE.Mesh(world,m1);
        scene.add(sp);

        camera.position.z = 120;
		
    	//}
		
		function latLongToVector3(lat, lon, radius, heigth) {
        	
        	var phi = (lat)*Math.PI/180;
        	var theta = (lon-180)*Math.PI/180;
 
        	var x = -(radius+heigth) * Math.cos(phi) * Math.cos(theta);
        	var y = (radius+heigth) * Math.sin(phi);
        	var z = (radius+heigth) * Math.cos(phi) * Math.sin(theta);
 
        	return new THREE.Vector3(x,y,z);
    }

		function render() {
			requestAnimationFrame(render);
			renderer.render(scene, camera);
			controls.update();
			//cube.rotation.x += 0.1;
			//cube.rotation.y += 0.1;
			
		}

		//window.addEventListener('resize', function () {
		//	camera.aspect = window.innerWidth / window.innerHeight;
		//	camera.updateProjectionMatrix();

		//	renderer.setSize(window.innerWidth, window.innerHeight);
	    //});
		var projector = new THREE.Projector(), 
				mouse_vector = new THREE.Vector3(), 
				mouse = { x: 0, y: 0, z: 1 },
				ray = new THREE.Raycaster(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0)),
				intersects = [];

		function onMouseDown(e) {
			//Evita que o evento chame outra função
			e.preventDefault();
			
			//Começa a tranformação entre coordenadas do rato e three.js
			mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
			mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
			

			//Vector 3D que indica a direção do vetor a partir do pixel
			mouse_vector.set(mouse.x, mouse.y, mouse.z);

			//Define um ponto no espaço 3D de acordo com o clique do rato
			projector.unprojectVector(mouse_vector, camera);

			var direction = mouse_vector.sub(camera.position).normalize();
			//Chama o raycaster com a posição da câmara e a direção
			ray.set(camera.position, direction);

			//Verifica se o raio intersetou algum objeto na cena
			/*for (var i = 0 ; i < countryBox.length-1 ; i++) {
				countryBox[i].material.color.setHex( 0xffffff );
//			cube.material.color.setHex( 0xffffff );
//			cube1.material.color.setHex( 0xffffff );
			}*/
			for (var i = 0 ; i < countryBox.length-1 ; i++) {
				intersects = ray.intersectObject(countryBox[i]);
				if (intersects.length) {
					DadosPais.innerHTML = MostraDados (countryRepresented[i])
					//cube.material.color.setHex( 0xff0000 );
					//scene.remove(countryBox[i])
					//alert (countryBox[i].material.color);
					countryBox[i].material.color.setHex( 0xff0000 );

				//alert("hit");
				}
			}
		}
			renderer.domElement.addEventListener('mousedown', onMouseDown);
		function MostraDados (linha)	
		{
			texto = "<b>Pais</b>:" + linha[0] + 
					"<br><b>Capital</b>:" +linha[1] + 
					"<br><b>Área:" + numeral(linha[4]).format('0,0') + " KM^2"+
					"<br><b>População</b>:" + numeral(linha[5]).format('0,0') + " Pessoas";


			return texto;
		}
 		function addData(countryData){
        	
        	//remover as barras anteriores
        	for (var i = 0 ; i < countryBox.length-1 ; i++) {
				scene.remove (countryBox[i]) 
			}
        	//the geometry that will contain all our cubes
	        countryRepresented = []

	        for (var i = 1 ; i < countryData.length-1 ; i++) {
	 
	            //get the data, and set the offset, we need to do this since the x,y coordinates
	            //from the data aren't in the correct format
	            var lat = parseInt(countryData[i][2]);
	            var lon = parseInt((countryData[i][3]));
	            var population = parseInt((countryData[i][5]));
	            var density = parseInt((countryData[i][6]));
	            var births = parseInt((countryData[i][8]));
	            var deads = parseInt((countryData[i][12]));

	           
	 			if ( population >100000000)
	 			{
	            	//adicionar dados
	            	addCountryData (lat,lon,population/ 5000000)
	            	countryRepresented.push (countryData[i])
				}
	        }
 
        // create a new mesh, containing all the other meshes.
        //var total = new THREE.Mesh(geom,new THREE.MeshFaceMaterial());
 
        // and add the total mesh to the scene
       	}
       	function addCountryData (lat,lon,value)
       	{
			var position = latLongToVector3(lat, lon, 59, 1);

	        // create the cube
			var cubeMat = new THREE.MeshLambertMaterial({color: 0xffffff,opacity:0.6, emissive:0xffffff});
	        var box = new THREE.BoxGeometry( 0.5, 0.5,  value );
			var cube = new THREE.Mesh( box, cubeMat );

	        // position the cube correctly
			cube.position.x = position.x;
			cube.position.y = position.y;
			cube.position.z = position.z;
	        cube.lookAt( new THREE.Vector3(0,0,0) );

	        // merge with main model
			scene.add( cube ); 
			countryBox.push (cube);
       	}
		render();
		//document.getElementbyID ("parametros").left=width;
		parametros.style.left  = 0;
		
            // position the cube correctly
            
	</script> 



</body> 
</html>